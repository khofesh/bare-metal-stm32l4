/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "stm32l4xx.h"
#include "adc.h"
#include "uart.h"
#include "systick.h"
#include "tim.h"
#include "exti.h"
#include "i2c.h"

#define PIN_5				(1U<<5)
#define LED_PIN				PIN_5

#define GPIOAEN				(1U<<0)

#define AF1_TIM				(1U<<20)

static void handle_i2c_master(void);
void slave_complete_callback(void);
void error_callback(void);

const uint8_t msg[] = "Hello";
uint8_t *p_tx_buff = (uint8_t*)msg;
uint8_t tx_size = sizeof(msg);
volatile uint8_t tx_idx = 0;

uint8_t rx_buff[sizeof(msg)];
uint8_t rx_size = sizeof(msg);
volatile uint8_t rx_idx = 0;

/**
 * use a jumper wire to connect SCL to SCL
 * and SDA to SDA
 */
/* PB8------------PC0  --- SCL*/
/* PB9------------PC1  --- SDA*/

int main(void)
{
	/* 1. enable clock access to GPIOA */
	RCC->AHB2ENR |= GPIOAEN;

	/* 2. set PA5 as output pin */
	GPIOA->MODER |= (1U<<10);
	GPIOA->MODER &= ~(1U<<11);

	uart2_tx_init(USART2);

	i2c1_slave_config();
	i2c3_master_config();

	handle_i2c_master();

	while(1)
	{

	}
}

static void handle_i2c_master(void)
{
	/* set slave address */
	I2C3->CR2 |= SLAVE_OWN_ADDRESS;

	/* set 7-bits address mode */
	I2C3->CR2 &= ~(1U<<11);

	/* set transfer size */
	I2C3->CR2 |= (tx_size<<16);

	/* set automatic end mode */
	I2C3->CR2 |= (1U<<25);

	/* generate start condition */
	I2C3->CR2 |= (1U<<13);

	/* loop until STOP flag is raised */
	while (!(I2C3->ISR & (1U<<5)))
	{
		/* check TXIS flag value in ISR register */
		if (I2C3->ISR & (1U<<1))
		{
			/* write data in Transmit Data register.
			 * TXIS flag is cleared by writing data in
			 * TXDR register
			 */
			I2C3->TXDR = (*p_tx_buff++);
		}
	}

	/* clear stop flag */
	I2C3->ICR |= (1U<<5);
}

void slave_reception_callback(void)
{
	/**
	 * read character in receive data register.
	 * RXNE flag is cleared by reading data in RXDR register
	 */

	/* read first 8 bits */
	rx_buff[rx_idx++] = (I2C1->RXDR & 0xFF);
}

void slave_complete_callback(void)
{
	printf("transfer complete\n\r");
}

void error_callback(void)
{
	printf("error happened\n\r");
}

void I2C1_EV_IRQHandler(void)
{
	/* check ADDR flag value in ISR register */
	if (I2C1->ISR & (1U<<3))
	{
		/* verify the address match with the own slave address */
		if (i2c1_get_address_matchcode() == SLAVE_OWN_ADDRESS)
		{
			/* verify the transfer direction, a write direction,
			 * slave enters receiver mode
			 */
			if ((I2C1->ISR & (1U<<16)) == 0)
			{
				/* clear ADDR flag value in ISR register */
				I2C1->ICR |= (1U<<3);

				/* enable receive interrupt */
				I2C1->CR1 |= (1U<<2);
			}
		}
	}
	/* check RXNE flag value in ISR register */
	else if (I2C1->ISR & (1U<<2))
	{
		/* do something */
		slave_reception_callback();
	}
	/* check STOP flag value in ISR register */
	else if (I2C1->ISR & (1U<<5))
	{
		/* clear stop flag */
		I2C1->ICR |= (1U<<5);

		/* do something */
		slave_complete_callback();
	}
	else
	{
		/* implement error routine */
		error_callback();
	}
}



